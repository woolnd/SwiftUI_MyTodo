//
//  RecordingManager.swift
//  N_VoiceMemoApp_SwiftUI
//
//  Created by wodnd on 6/5/25.
//

import Foundation
import AVFoundation

class RecordingManager: NSObject, ObservableObject, AVAudioPlayerDelegate {
    @Published var isRecording = false
    @Published var isPlaying = false
    @Published var recordingTime: String = "00:00"

    private var audioRecorder: AVAudioRecorder?
    private var audioPlayer: AVAudioPlayer?
    private var timer: Timer?
    private var startTime: Date?
    private(set) var recordedFileURL: URL?
    private(set) var currentFileName: String?

    func toggleRecordingOrPlayback() {
        if isRecording {
            stopRecording()
        } else if let url = recordedFileURL, FileManager.default.fileExists(atPath: url.path) {
            playRecording()
        } else {
            let autoGeneratedFileName = UUID().uuidString
            currentFileName = autoGeneratedFileName
            startRecording(fileName: autoGeneratedFileName)
        }
    }

    private func startRecording(fileName: String) {
        let url = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]
            .appendingPathComponent("\(fileName).m4a")
        recordedFileURL = url

        let session = AVAudioSession.sharedInstance()
        do {
            try session.setCategory(.playAndRecord, mode: .default)
            try session.setActive(true)

            let settings: [String: Any] = [
                AVFormatIDKey: Int(kAudioFormatMPEG4AAC),
                AVSampleRateKey: 12000,
                AVNumberOfChannelsKey: 1,
                AVEncoderAudioQualityKey: AVAudioQuality.high.rawValue
            ]

            audioRecorder = try AVAudioRecorder(url: url, settings: settings)
            audioRecorder?.record()
            isRecording = true
            isPlaying = false
            startTime = Date()
            startTimer()
        } catch {
            print("녹음 시작 실패: \(error)")
        }
    }

    private func stopRecording() {
        audioRecorder?.stop()
        isRecording = false
        stopTimer()
    }

    private func playRecording() {
        guard let url = recordedFileURL else { return }

        let session = AVAudioSession.sharedInstance()
        do {
            try session.setCategory(.playAndRecord, mode: .default)
            try session.overrideOutputAudioPort(.speaker)
            try session.setActive(true)

            audioPlayer = try AVAudioPlayer(contentsOf: url)
            audioPlayer?.delegate = self
            audioPlayer?.play()
            isPlaying = true
        } catch {
            print("재생 실패: \(error)")
        }
    }

    func audioPlayerDidFinishPlaying(_ player: AVAudioPlayer, successfully flag: Bool) {
        isPlaying = false
    }

    private func startTimer() {
        timer = Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) { _ in
            guard let start = self.startTime else { return }
            let elapsed = Int(Date().timeIntervalSince(start))
            let m = String(format: "%02d", elapsed / 60)
            let s = String(format: "%02d", elapsed % 60)
            self.recordingTime = "\(m):\(s)"
        }
    }

    private func stopTimer() {
        timer?.invalidate()
        timer = nil
    }

    func resetRecording() {
        stopRecording()
        isRecording = false

        if let url = recordedFileURL, FileManager.default.fileExists(atPath: url.path) {
            try? FileManager.default.removeItem(at: url)
        }

        recordedFileURL = nil
        recordingTime = "00:00"
        currentFileName = nil
    }
}

